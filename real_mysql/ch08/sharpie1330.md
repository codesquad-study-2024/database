# 08. 인덱스
## 8.1 디스크 읽기 방식

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브 (SDD)
기계식 보다 전자식 저장 매체 사용이 효율적
- SSD는 기존 HDD에서 원판(저장용 플래터)을 제거, 대신 플래시 메모리 장착
  - 저장용 플래터의 기계식 회전 없이 빠른 데이터 I/O
  - 전원 공급 없이 데이터 삭제되지 않음
  - DRAM보다 느리지만 HDD보다 빠름
- 처리 속도 => 메모리와 디스크 : 10만 배 이상 차이 / 메모리와 SSD : 1000배 가량 차이
- 순차 I/O에서는 SSD가 HDD와 거의 비슷하기도
- 그러나 SSD가 **랜덤 I/O 더 빠르다**는 장점
- DB 서버에서 대부분 랜덤 I/O가 대부분이므로 SSD의 장점은 DBMS에 최적
- 기존 HDD보다 용량 ↓, 가격 ↑지만 전보다 대중화
- 최근 DBMS용 서버는 대부분 SSD 채택

### Random I/O, Sequential I/O
#### HDD
- 랜덤 I/O : HDD의 플래터(원판)을 돌려 데이터 저장 위치로 헤더 이동해 읽기
- 순차 I/O도 이 작업 과정은 동일
- 그렇다면 어떤 차이?
  - 순차 : 한 번의 시스템 콜
  - 랜덤 : 세 번 시스템 콜
  - 이 경우 순차가 3배 정도 빠르다
- 디스크 헤더 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 성능 결정
- 랜덤이 작업 부하가 크지만, DB 대부분 작업은 대부분 이런 작업. MySQL에는 그룹 커밋, 로그 버퍼 등 기능 내장
#### SSD
- 랜덤 I/O 여전히 순차보다 전체 Throughput 떨어짐, 따라서 사양에 항상 둘의 성능 비교 구분해 명시
- 쓰기 실행 시 반드시 동기화(flush, fsync) 필요 => 순차여도 이런 작업 빈번히 발생 시 랜덤과 마찬가지로 비효율
- 기업용의 경우 캐시 메모리 장착 RAID 컨트롤러 일반적 사용 -> 순차 I/O 효율적 처리할 수 있도록 변환하는 역할
- 쿼리 튜닝해 랜덤 -> 순차 어려움
- 쿼리 튜닝은 랜덤 i/o 자체를 줄여주는 것이 목적. (쿼리 처리에 꼭 필요한 데이터만 읽도록 개선)
- 통계 작업 등에서 일부로 풀 테이블 스캔 유도하기도(순차 I/O 사용으로 랜덤 I/O 사용하는 인덱스 레인지 스캔보다 성능 굿)

## 8.2 인덱스란?
- 대부분의 사람들 -> 책의 맨 끝의 찾아보기(색인) / 그렇다면 책의 내용은 데이터 파일 / 페이지 번호는 데이터 파일에 저장된 레코드의 주소
- 모든 데이터 검색 시간 소요 -> 칼럼의 값과 해당 레코드 저장된 주소를 키-값 쌍으로 인덱스를 만들어 두는 것
- 이때 "정렬"이 중요 : 칼럼의 값을 주어진 순서로 미리 정렬해 보관
- SortedList와 ArrayList : 전자는 인덱스, 후자는 데이터 파일과 유사. 전자는 저장되는 값을 항상 정렬된 상태로 유지, 후자는 저장되는 순서 그대로 유지
- DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼 값을 이용해 항상 정렬된 상태 유지
- 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도 정렬 없이 그대로 저장
- SortedList의 장단점 
  - 데이터가 저장될 때마다 항상 정렬. 저장 과정이 복잡, 느림
  - 이미 정렬되어 있어 아주 빠른 조회 가능
- DBMS의 인덱스의 장단점
  - 인덱스 많은 테이블은 INSERT, UPDATE, DELETE 느림
  - 대신 SELECT를 매우 빠르게 처리 가능
- 즉, 인덱스는 데이터 저장 성능을 희생하고 대신 읽기 속도를 높임
- 인덱스 추가는 저장 속도를 얼마나 희생할 수 있는지, 읽기 속도를 얼마나 향상시킬건지에 따라 결정
- 인덱스는 데이터 관리 방식(알고리즘)과 중복 값 허용 여부 등에 따라 여러 가지로 나눠볼 수 있음

### 분류
- 데이터를 관리하는 방식(알고리즘)과 중복 값의 허용 여부 등에 따라 여러 가지로 나눠볼 수 있음
- Key, Index를 같은 의미로 사용한다면
- 역할별
  - Primary Key, Secondary Key(세컨더리 인덱스, 보조 키)
  - 전자는 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스, 레코드 식별 기준값이 되므로 식별자라고도 함. NULL 미허용, 중복 미허용.
  - 전자를 제외한 나머지 모든 인덱스. 유니크 인덱스는 프라이머리 키와 성격 비슷하고 대체 가능하다 해 대체 키라고도 하기도.
- 알고리즘별
  - B-Tree, Hash
  - 전자의 경우 가장 일반적. 상당히 오래되어 그만큼 성숙. 칼럼 값 변형 없이 원래 값을 이용해 인덱싱. 
  - 후자의 경우 칼럼의 값으로 해시값 계산해 인덱싱. 매우 빠른 검색 지원. 값을 변형해 인덱싱하므로 Prefix 일치와 같이 값 일부만  검색하거나 범위 검색 시 해당 인덱스 사용 불가. 주로 메모리 기반 DB에서 많이 사용.
  - Fractal-Tree 인덱스나 로그 기반 Merge-Tree 인덱스 알고리즘 사용하는 DBMS도 개발 중
- 데이터 중복 허용 여부별
  - Unique, Non-Unique
  - 실제 DBMS 쿼리 실행하는 옵티마이저에게는 단순히 값이 1개 존재하는지 1개 이상 존재할 수 있는지가 중요한 문제
  - 동등 조건(=)으로 검색 : 하나만 찾으면 더 안찾아도 됨
  - 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점 매우 다양
- 인덱스 기능별
  - 전문 검색용 인덱스, 공간 검색용 인덱스

## 8.3 B-Tree 인덱스
- 여러 변형 알고리즘 존재 : 일반 DBMS에서는 주로 B+-Tree나 B*-Tree가 사용
- B는 Binary가 아니라 Balanced
- 칼럼의 원래 값 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지
- 일반적 용도에 적합

### 구조 및 특성
- 최상위에 루트 노드가 존재, 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조 가장 하위 노드를 리프 노드, 루트도 리프도 아닌 중간 노드를 브랜치 노드라고 함
- 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값 가짐
![image](https://blog.kakaocdn.net/dn/nt7dT/btsH9VH5i5B/w9K1RKbvEuOysCCEXppZb1/img.png)
- 그림에서 인덱스 키 값은 모두 정렬되어 있지만 데이터 파일 레코드는 정렬 x, 임의의 순서로 저장되어 있음
- 레코드가 삭제되어 빈 공간 발생시 다음 INSERT는 가능한 한 공간 재활용하도록 설계되므로 INSERT된 순서대로 저장되지는 않음
- *InnoDB의 경우 레코드가 클러스터되어 디스크에 저장되므로 프라이머리 키 순서대로 정렬되어 저장된다.
- 인덱스는 테이블 키 칼럼만 가지므로 나머지 칼럼 읽으려면 데이터 파일에서 해당 레코드를 찾아야
- 리프노드는 데이터 파일에 저장된 레코드의 주소를 가짐
- MyISAM의 경우 : 레코드는 MyISAM 테이블 생성 옵션에 따라 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)
- InnoDB의 경우 : 프라이머리 키가 ROWID의 역할.
- 전자의 경우 세컨더리 인덱스가 물리적 주소를 가지는 반면 후자는 프라이머리 키를 주소처럼 사용하므로 논리적 주소를 가진다고 볼 수 있음
- InnoDB에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못함
  - 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프리이머리 키 인덱스를 한번 더 검색 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다. 
  - 즉 InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야

### B-Tree 인덱스 키 추가 및 삭제
#### 인덱스 키 추가 
- 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 아닐수도
  - 리프 노드가 꽉 차면 분리되어야(Split) -> 상위 브랜치 노드까지 처리의 범위가 넓어짐
  - 따라서 상대적으로 쓰기 작업에 비용 많이 듬
- 인덱스 추가로 INSERT나 UPDATE는 어떤 영향?
- 테이블 칼럼 수, 칼럼 크기, 인덱스 칼럼의 특성 고려해야
- 대략적 계산 => 레코드 추가 1, 인덱스에 키 추가 1.5로 예측
- 테이블 모든 인덱스가 B-Tree고 3개 있다면 : 1.5 * 3 + 1
- 이 비용의 대부분이 메모리 CPU에서 처리하는 시간 x -> 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간
#### 인덱스 키 삭제
- 해당 키 값 저장된 B-Tree 리프 노드 찾아서 그냥 삭제 마크
- 이 공간은 계속 방치되거나 재활용 가능
- 이것도 디스크 I/O가 필요한 작업
- 5.5 이후 버전 InnoDB에서는 버퍼링되어 지연될 수 있지만 내부적으로 처리됨
#### 인덱스 키 변경
- 인덱스 키 값은 그 값에 따라 저장될 리프 노드 위치 결정됨. 따라서 단순 인덱스상 키 값 변경은 불가능
- 먼저 키 값을 삭제하고 다시 새로운 키 값을 추가하는 형태로 처리됨
#### 인덱스 키 검색
- 인덱스 관리에 따르는 추가 비용을 감당하며 인덱스를 구축하는 이유 -> 빠른 검색
- 검색 작업은 루트 노드부터 시작, 브랜치를 거쳐 최종 리프 노드까지 이동하며 비교 작업 수행 => 트리 탐색
- SELECT, UPDATE, DELETE(작업 전 먼저 조회)에서 사용
- B-Tree 인덱스를 이용한 검색은 100%일치나 Left-most part만 일치하는 경우 사용 가능
- 부등호 비교 조건에서 인덱스 활용 가능하지만 키 값의 뒷부분만 검색하는 용도로는 사용 불가
- 인덱스 키 값에 변형이 가해진 후 비교되는 경우 절대 B-Tree의 빠른 검색 기능 사용 불가
- 따라서 함수나 연산 수행 결과로 정렬, 검색 작업은 장점 이용 불가 주의
- InnoDB에서는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있음. 따라서 UPDATE나 DELETE 문장 실행 시 테이블에 적절히 사용할 수 있는 인덱스 없으면 불필요하게 많은 레코드 잠금. 테이블 모든 레코드 잠글 수도 있으니 주의.

### B-Tree 인덱스 사용에 영향을 미치는 요소
- InnoDB 스토리지 엔진이 디스크에 데이터를 저장하는 가장 기본 단위 : Page 또는 Block
-> 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 됨
- 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도
- 인덱스도 결국 페이지 단위로 관리
- B-Tree는 자식 노드의 개수가 가변적인 구조 => 인덱스 페이지 크기와 키 값의 크기에 따라 결정
- innodb_page_size 시스템 변수로 4-64KB 사이 값 선택 가능하나 기본값은 16KB
- 자식 노드 주소 : 6바이트에서 12바이트까지 다양한 크기 값 가질 수 있는 여러 복합적 정보 담긴 영역
- 편의상 자식 노드 주소 영역 평균적 12바이트라 가정하면 => 페이지에 `16 * 1024 /(16+12) = 585`개 저장 가능
- 인덱스 키 값이 커지면 => 32바이트라 할 때 `16 * 1024 / (32 + 12) = 372`개 저장 가능
- SELECT 쿼리가 500개를 읽어야 한다면 전자는 인덱스 페이지 한 번으로 끝나지만 후자는 최소 2번 이상 디스크 읽어야
- 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수 증가, 그만큼 느려짐
- 키 값 길이가 늘어난다는 건 전체적 인덱스 크기가 커진다는 것 의미
- 인덱스 캐시하는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역 크기 제한적 -> 인덱스 크기가 커질수록 캐시 가능 레코드 수 감소, 메모리 효율 떨어짐

#### B-Tree 깊이
- Depth는 상당히 중요하나 직접 제어할 방법 없음
- 인덱스 키 평균 크기가 늘어나면
- 키 값 16바이트인 경우 최대 2억 (585 * 585 * 585)개 정도 키 값 담을 수 있음
- 32바이트로 늘어나면 5천만 ( 372 ^ 3 ) 개로 줄어듦
- depth는 MySQL에서 값 검색할 때 몇번이나 랜덤io를 해야하는지와 직결
- 인덱스 키 값 커질수록 depth가 깊어져 읽기가 더 많이 필요
- 인데스 키 값 크기가 작을수록 좋다는 내용. 아무리 대용량이어도 depth가 5단계 이상까지 깊어지는 경우는 흔치 않다.

#### 선택도(기수성)
- Selectivity, Cardinality : 거의 같은 의미로 사용, 모든 인덱스 키 값 가운데 유니크한 값의 수 의미
- 전체 인덱스 키 값 100개, 유니크 값이 10개라면 기수성은 10
- 중복 값이 많아질수록 기수성 낮아지고 동시에 선택도도 떨어짐
- 선택도가 높을수록 검색 대상이 줄어들어 그만큼 빨리 처리
- 선택도가 좋지 않아도 정렬이나 그루핑으로 인덱스를 만드는 게 훨씬 나은 경우도, 여러가지 용도 고려해 설계

```
SELECT * FROM tb_test WEHERE country='KOREA' AND city='SEOUL';
```
- country 칼럼에만 인덱스, 레코드 건수 10000건, 케이스 A는 유니크값 10, B는 1000일 때
- MySQL에서 인덱스 통계 정보(유니크한 값의 개수)가 관리되므로 city 칼럼 기수성은 작업 범위에 아무런 영향 x
- A는 평균 1000건, B는 평균 10건 조회될 수 있다는 것을 인덱스 통계 정보로 예측 가능
- 둘다 실제 조건 만족 레코드 단 1건 존재시 A 인덱스는 부적합
- A는 1건을 위해 999를 더 읽었고, B는 9건만 더 읽은 것

```
CREATE TABLE tb_city(
  country VARCHAR(10),
  city VARCHAR(10),
  INDEX ix_country (country)
);
```
- 각 국가 도시 저장하는 tb_city 테이블, 1만 건 레코드, country에만 인덱스, 국가나 도시가 중복해 저장되어 있지 않을 때
- `SELECT * FROM tb_city WHERE country='KOREA' AND city='SEOUL'; 실행하면 
- country 칼럼 유니크 값 10개면 : 10개 국가의 도시정보 저장, country='KOREA' 조건으로 인덱스 검색 시 1000건 일치. 그러나 그 결과에서 city의 경우 1건이므로 999건은 불필요
- country 칼럼 유니크 값 1000개면 : 1000개 국가의 도시정보 저장. 이 케이스에서도 대략 10건. 그 결과 중에서 city 조건은 9건만 불필요하게 읽은 것.
- 앞 두 케이스 테이블에서 똑같은 쿼리를 실행해 똑같은 결과를 받았지만 사실 두 쿼리가 처리되기 위해 MySQL 서버가 수행한 작업 내용은 매우 크다.
- 인덱스에서 유니크 값 개수는 인덱스나 쿼리의 효율성에 큰 영향

#### 읽어야 하는 레코드의 건수
- 20-25%가 넘어서면 인덱스 사용 이점이 없으므로 그냥 테이블 풀스캔해서 필터링하는 것이 효율적

### B-Tree 인덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
- 인덱스 풀 스캔
- 루스 인데스 스캔
- 인덱스 스킵 스캔
- Q. 카디널리티 2인 gender 칼럼과 birthdate로 구성된 인덱스에 대해 birthdate만 사용해 두 칼럼을 조회한다면 인덱스 풀스캔과 성능상 다를 게 뭐지?

### 다중 칼럼 인덱스
- 2개 이상 칼럼으로 구성
- 브랜치 노드는 없을 수 있어도 루트와 리프 노드는 항상 존재
- 칼럼이 4개라면 -> 두번째는 첫번째 칼럼에 의존해 정렬, 세번째는 두번째에, 네번째는 세번째에...
- 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하고 신중히 결정해야 함

### B-Tree 인덱스의 정렬 및 스캔 방향
- 5.7버전까지 칼럼 단위로 정렬 순서 혼합해 인덱스 생성 불가능
- 8.0 부터는 혼합해서 가능
- 5.7에서는 문법상으로만 존재했지 실제로는 오름차순으로만 인덱스 생성되었을 것
#### 인덱스 스캔 방향
- 인덱스를 최솟값부터 -> 오름차순
- 최댓값부터 -> 내림차순
- 물론 두개 이상 칼럼이 복합적 정렬을 동시에 사용하는 쿼리에서는 각 칼럼이 각각 차순으로 정의된 복합 칼럼 인덱스 필요
- Forward Index Scan, Backward Index Scan -> 인덱스 키 크고 작음 상관없이 리프 노드 왼쪽 페이지부터 오른쪽 / 오른쪽 페이지부터 왼쪽
- 1천 2백여만 건 데이터 테이블을 풀 스캔하면서 정렬만 수행하는 쿼리 `LIMIT... OFFSET...` 사용 => 역순 정렬 쿼리가 28.9% 더 시간 소요
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이고. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조임
- 실제로 InnoDB 페이지는 힙(Heap)처럼 사용되므로 물리적으로 저장이 순서대로 배치되지는 않음
- 많은 쿼리가 인덱스의 앞쪽 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 될 것

### B-Tree 인덱스의 가용성과 효율성
- 비교 조건에 따라 인덱스 칼럼 활용 형태와 효율이 달라짐
- 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업 => 필터링
- 다중 칼럼 인덱스 정렬 방식 때문에 작업 범위 결정 조건이 아닌 필터링 조건이나 체크 조건은 비교 작업 범위 좁히는 데 도움이 안될 수 있음
  - 필터링 조건, 체크 조건 : 비교 작업 범위를 줄이지 못하고 단순히 거름종이 역할
- 작업 범위 결정 조건은 많을수록 쿼리 처리 성능을 높이지만 체크 조건은 많다고 해서 처리 성능을 높이지는 못하고 오히려 느리게 만들수도

#### 인덱스의 가용성
- B-Tree 인덱스 특징 : 왼쪽 값 기준(Left-most)으로 오른쪽 값 정렬
- 다중 칼럼 인덱스 칼럼에 대해서도 적용
- 인덱스 칼럼의 이런 정렬 특성은 빠른 검색의 전제 조건.
- 하나 칼럼으로 검색해도 값의 왼쪽 없으면 인덱스 레인지 스캔 방식의 검색 불가능
- 다중 칼럼 인덱스에서도 왼쪽 칼럼 값 모르면 인덱스 레인지 스캔 불가

#### 가용성과 효율성 판단
- 다음 조건에서 작업 범위 결정 조건으로 사용 불가
  - NOT-EQUAL로 비교
  - LIKE '%??'형태로 비교
  - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교
  - NOT-DETERMINISTIC 속성 스토어드 함수가 비교 조건에 사용
  - 데이터 타입이 서로 다른 비교
  - 문자열 데이터 타입의 콜레이션이 다른 경우
- 다른 DBMS와 달리 MySQL에서는 NULL값도 인덱스에 저장됨
- 다중 칼럼 인덱스의 경우
  - ...
 
## R-Tree 인덱스
- 공간 인덱스는 R-Tree 인덱스 알고리즘 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스
- 기본적인 내부 매커니즘은 B-Tree와 흡사
- 공간 확장 이용해 GPS 등의 기능 간단히 구현
  - 공간 데이터 타입
  - 검색을 위한 공간 인덱스
  - 공간 데이터 연산 함수(거리 또는 포함 관계 처리)
