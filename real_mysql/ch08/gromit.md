# 8.1 디스크 읽기 방식
### HDD 와 SSD
#### # 전자식 장치 vs 기계식 장치
- CPU, 메모리, SSD(HDD 대안, 전자식 저장 매체) → 전기적 특성인 전자식 장치
- 하드 디스크 (HDD)→ 기계식 장치(원판)
 
- HDD 는 원판에 데이터를 저장.
- SSD 는 전원이 공급되지 않아도 데이터가 삭제되지 않는 플래시 메모리에 저장. (D-Ram인 메모리보단 느리다)

- 순차 I/O HDD 는 원판으로 읽음 → SSD 와 데이터를 순차적으로 읽을 때 조금 느림
- 랜덤 I/O 에서 SSD 는 HDD 를 회전시킬 필요 없기 때문에 아주 빨리 데이터를 읽고 쓸 수 있다.

- SSD 도 순차I/O 가 랜덤I/O 보다 성능이 빠르다. → 사양에서 항상 순차,랜덤I/O 의 성능이 비교된다.
- DBMS 는 SSD 를 채택.
- 그럼 쿼리를 튜닝한다는 것은 랜덤I/O 자체를 줄여주는 것이 목적이다. → 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것.
- 인덱스 Range 스캔 → 주로 랜덤 I/O 를 사용, 풀 테이블 스캔 → 순차I/O
- 그래서, 큰 테이블의 레코드 대부분을 읽는 작업의 쿼리 실행은 인덱스를 사용하지 않고(인덱스 Range스캔) 풀 테이블 스캔을 사용하도록 유도할 때도 있다.

# 8.2 인덱스란?
#### 인덱스 개념
- 인덱스를 책의 ‘찾아보기’ or ‘색인’이라 비유한다.
- 책의 ‘찾아보기’ 파트에는 ㄱ,ㄴ,ㄷ, 순서로 정렬되어있는 덕분에 우리는 빠르게 특정 단어를 ‘찾아보기’를 통해 찾을 수 있다.

- 인덱스도 마찬가지다. DBMS 인덱스도 column 의 값을 주어진 순서로 미리 정렬해서 보관한다.

#### 인덱스 구조 및 특징
- 인덱스는 key-value 로 만들어 진다. key 에는 column 의 값, value 에는 데이터 파일(데이터라고 봐도 무방하다)이 저장된다.
- DBMS의 인덱스는 저장되는 column 의 값을 이용해 항상 정렬된 상태를 유지한다.

- 항상 정렬을 유지해야 하기 때문에, 인덱스를 만들어서 저장하는 과정이 느리다.
- 그렇지만, 항상 정렬이 되어있기 때문에 매우 빨리 원하는 데이터를 찾아올 수 있다.(SELECT)

```angular2html
즉, 인덱스가 많은 테이블에서 INSERT, UPDATE, DELETE 문장의 처리는 느려진다. 
하지만, SELECT 는 매우 빠르다 → CQRS (데이터의 **명령(Command)**(즉, 데이터를 변경하는 작업)과 **조회(Query)**(즉, 데이터를 읽는 작업)를 분리하는 패턴) 을 들어 본 적이 있다.  
CQRS 패턴을 통해 또한, 트랜잭션을 엄격히 관리하는 쓰기 DB 와 읽기 DB를 나눠 조회 성능을 높인다고 알 수 있었따. 이러한 이유였음을 알게 되었다.
인덱스가 많은 테이블에서 조회 성능을 높이기 위해 CQRS 패턴을 사용할 수 있겠다.
```

**본론, 인덱스는 데이터의 저장(쓰기)성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다.
즉, 테이블에 쓰기작업이 빈번할 때, 인덱스를 추가할 때마다 쓰기작업 성능이 매우 안나올 것이다.**

- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어아ㅑ 할지를 결정해야 한다.
- SELECT 의 WHERE 절에 사용되는 column 이라고 전부 인덱스를 생성하면 쓰기 작업 성능이 떨어진다.

#### 인덱스 역할
- 인덱스를 역할 별로 구분 → PK 와 보조키(세컨더리 인덱스)로 구분할 수 있다.
- PK는 레코드(데이터)를 대표하는 column 의 값으로 만들어진 인덱스, null 허용 x ,중복 허용 x
- PK를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다.
- unique 인덱스는 pk 와 성격이 비슷하고 PK를 대체해서 사용할 수 있어서 대체키라고도 한다. 이는 별도로 분류하기도 하고, 그냥 세컨더리 인덱스로 분류하기도 한다.
- 인덱스를 만드는 알고리즘 대표적으로 B-Tree 와 Hash 로 구분할 수 있다.
- B-Tree 인덱스는 column 에 저장된 실제 데이터를 그대로 사용해서 인덱스를 만듭니다.
- Hash 인덱스는 column 의 값으로 해시값을 계산해서 인덱스를 합니다. → 해시맵의 조회가 O(1) 인 것처럼, Hash 인덱스일 경우 조회속도가 매우 빠르다.
- 하지만, column 의 값을 변형하기 때문에 column 의 값으로 범위 검색을 하거나 일부만을 검색할 때는 인덱스를 사용할 수 없습니다.
- 그렇기 때문에 이러한 Hash인덱스는 메모리DB인 Redis 나 스프링부트의 내장된 메모리DB인 h2 에서 사용됩니다.

# B-Tree 인덱스
#### B-Tree 인덱스 개념
- B-Tree 의 B는 Binary(이진) 트리가 아니라 Balanced 를 의미한다.
- B-Tree 는 column 의 실제 데이터 값으로 인덱스를 만든다는 점 다시 한 번 리마인드!(명확히는 값의 앞부분만 잘라서 관리합니다)

#### B- Tree 구조 및 특성
- B-Tree 는 트리 구조의 최상위에 하나의 루트(Root) 노드가 존재하고, 그 하위에 자식 노드가 붙는다.
- 트리구조의 가장 하위에 있는 노드를 리프(Leaf) 노드라 하고, 트리구조에서 루트도 리프도 아닌 중간 노드를 브랜츠(Branch) 노드라 한다.
- 인덱스(B-Tree)의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
  - 인덱스 및 데이터 레코드는 저장되어야 하니까 SSD 에 있겠죠?

- 인덱스의 키는 정렬되어 있지만, 대부분의 RDBMS에서 데이터 레코드는 정렬돼 있지 않고 무작위 순서로 저장됩니다.(이렇게 무작위 순서로 저장되기 때문에 → Random I/O 가 발생하고, 이러한 RandomI/O 줄이기 위해 정렬되어 있는 인덱스로 조회를 하여 순차 I/O 로 바꾸는 것이죠)
- 물론, 인덱스를 생성하지 않는다면 PK 로 만들어진 B-Tree 인덱스를 1번만 탐색하여 데이터를 찾겠죠.

- 만약, InnoDB 엔진의 Mysql8.0 에서 PK 이외의 세컨더리 인덱스를 생성하여  해당 세컨더리 인덱스로 데이터 레코드를 찾을 때, B-Tree 를 2번 탐색합니다.
- 세컨더리 인덱스 B-Tree 의 key-value 에서 value 에는 PK값이 들어가고, 해당 세컨더리 인덱스의 해당하는 key 로 PK를 찾은 다음, 찾은 PK로 PK B-Tree 를 한 번 더 탐색하여 데이터 레코드를 얻는 방식입니다.

- 즉, **InnoDB 테이블에서 레코드는 클러스터되어 논리적인 PK 순서로 정렬되어 저장됩니다, 실제 물리적인 디스크에는 정렬되어 저장되진 않습니다.**

- 세컨더리 인덱스를 만들수록 B-Tree 인덱스가 추가적으로 생기게 됩니다.
- 이 방식의 장단점은 클러스터링 인덱스에서 자세히 살펴봅니다.

**8.3.2 B-Tree 인덱스 키 추가 및 삭제**

- 데이터 레코드는 인덱스에 의해 정렬되어 있는 것을 확인하였습니다.
- 그렇기에 인덱스는 쓰기 작업의 성능을 포기하고 읽기 작업의 성능을 얻고자 하는 것이라고 다시 한 번 상기시키면서
- 인덱스의 키가 추가될 때를 알아보겠습니다.
- 레코드가 추가되어 세컨더리 인덱스 B-Tree 에 노드(인덱스)를 추가 한다면,
- 이 노드를 B-Tree 어디에 저장할지, 탐색도 해야할뿐더러 적절한 위치를 찾아서 리프노드에 저장할 때, 리프노드가 꽉차 있다면 리프노드를 분리하는 작업이 발생합니다. 그래서, B-Tree 는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려져있따.
- 다만, InnoDB 스토리지 엔진은 이 작업을 지연시켜 나중에 처리할 수 있습니다. 하지만, PK 나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree 에 추가하거나 삭제합니다.
- Memory 스토리지, MyISAM 스토리지 엔진을 사용하는 테이블에서는 즉이 B-Tree 인덱스에 반영합니다.

- 인덱스 키 삭제는 그냥 해당 키를 삭제하면 됩니다.
- 인덱스 키 변경 → 단순히 값을 덮어씌우는 것이 아니라, 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리됩니다.
- 인덱스 키 검색

- 인덱스를 검색하는 건 SELECT 뿐 아니라 DELETE, UPDATE 를 처리하기 위해 항상 레코드를 먼저 검색할 경우에도 사용됩니다.
- B-Tree 인덱스를 이용한 검색은 100% 일치, 부등호(<, >) 인 비교조건에서 사용가능하다
- 값의 앞부분 예를 들면 Like “Ahn*” 에는 인덱스를 활용할 수 있지만 Like “*Hyeok” 같이 혁으로 끝나는 단어를 찾는데에는 인덱스를 활용할 수 없다.
- 또한, 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree 인덱스를 사용할 수 없습니다. 
- 예를들어, ‘Jonh don’ 란 customer_name 을 테이블에 넣고, 인덱스를 생성했습니다.
- `CREATE INDEX idx_customer_name ON customers(customer_name);`

- 만약, customer_name  을 UPPER 함수로 대문자로 변경한 다음에 변경한 값으로 레코드를 찾고자 한다면, 변경한 값이 인덱스에 없기 때문에 인덱스를 사용할 수 없습니다.
- `SELECT * FROM customers WHERE UPPER(customer_name) = 'JOHN DOE';`

- 더욱 중요한 것, UPDATE 나 DELETE 문장이 실행될 때, 테이블에 적절히 사용할 수 없는 인덱스가 없으면 불필요하게 많은 레코드를 잠급니다. 모든 테이블의 레코드를 잠글 수 있습니다.
```
CREATE TABLE employees (
id INT PRIMARY KEY,
name VARCHAR(100),
department VARCHAR(100)
);

UPDATE employees
SET department = 'HR'
WHERE department = 'Engineering';
```
- department 에는 인덱스가 없기 때문에 Enginering 인 레코드를 찾기위해 모든 레코드를 찾게 되고, 이 과정에서 레코드에 잠금을 걸어 다른 트랜잭션이 이 레코드에 접근 할 수 없게됩니다.
- 그래서 InnoDB 스토리지 엔진인 MYsql8.0 에서는 인덱스의 설계가 매우 중요하다고 봅니다.
- 
- 8.3.3.1 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) or 블록(Block) 이라 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
- 페이지 vs 파일 : 여러 개의 페이지가 모여 하나의 파일을 이루어집니다. 하나의 파일을 읽는 다는 것은 최소 작업 단위인 페이지들을 여러 번 읽는 것입니다.
- B-Tree 도 디스크에 저장이 되기 때문에 B-Tree 의 노드들도 페이지 단위로 읽고 쓰여집니다.
- 즉, B-Tree 의 노드들이 적게 있다면 B-Tree 구조는 1개의 페이지 단위로도 저장이 될 수 있지만, 노드가 많다면 B-Tree 구조를 다 탐색하려면 몇 개의 페이지 단위를 읽게 됩니다.
- MySQl .57 버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 `innodb_page_size`  시스템 변수를 이용해 4KB ~ 64KB 사이의 값을 선택할 수 있지만, 기본값은 16KB입니다.
- 그렇다면 인덱스 페이지 크기가 16KB 로 가정, 인덱스 키가 16Byte, 값이 12Byte 라 가정한다면,
- 16KB 인 인덱스 페이지에는 16 * 1024 (Byte) / 16(키) + 12(값) (Byte) 를 연산하면 585개의 자식노드를 읽을 수 있게 됩니다.
- 만약, 이 경우엔 B-Tree 에 노드가 1000개 있다면,  모든 노드를 탐색하려면 페이지를 2번 읽어야 하고(1번당 585개의 노드만 읽을 수 있기 때문), 이는 디스크 I/O 가 2번 생긴다는 의미입니다.
- 만약, 인덱스 키가 32Byte 로 늘어난다면 16KB인 인덱스 페이지는 16 * 1024 / 32 + 12 를 연산하고 이는 372개의 노드만을 읽을 수 있게 됩니다.
- 결국 인덱스를 구성하는 키 값의 크기(Byte)가 거지면 디스크I/O 횟수가 늘어나고, 그만큼 성능 저학 발생합니다.
- 즉, 인덱스 키를 구성하는 타입이 VARCHAR(255) 최대 255바이트나 BLOB 같은 타입을 인덱스로 설정하면 안된다는 얘기입니다.
- B-Tree 깊이도 페이지를 읽을 때, 상당히 중요하지만 제어할 수 방법은 없다는 것을 참고차 알아가셔도 좋습니다.

- 8.3.3.3 선택도

- 선택도란 모든 인덱스 키 값 중에 유니크한 값의 수를 의미합니다.
- 인덱스를 설계할 때의 중요점은 해당 column 이 얼마나 unique 한 값들을 가지고 있는지 확인해야 합니다.
- 10000건의 레코드에서 number란 column 의 선택도가 10 이라고 가정(숫자가 column 의 값이 1~ 10 으로만 구성)하고, number 에 인덱스를 겁니다.
- 그렇다면 만약 숫자가 3인 레코드를 찾고싶어서 WHERE number=3 쿼리를 실행했을 때, 10000건 / 10 한 값인 1000건 정도가 나올 것이라 옵티마이저가 예상합니다. →
- 하지만, 만약 실제 레코드는 단 1개만 있었다면? 인덱스를 통해 검색된 1000건 중, 1건의 레코드를 찾기 위해 999건을 불 필요하게 읽은 것입니다.
- 그래서, number 에 인덱스 걸어도 효율은 좋지 않을 것이며, 다른 column 에 대한 인덱스를 설계해봐야 합니다.
- 만약, 선택도가 1000이라면 (1~1000으로 구성) , 예상 값은 10000 / 1000 으로 10건입니다. 10건 중에서 1건을 찾게 됩니다.
 ```java
SELECT
  COUNT(DISTINCT column_name) / COUNT(*) AS selectivity
FROM
  table_name;
를 통해 특정 컬럼에 인덱스를 걸기 전 선택도를 계산하고, 여기서는 1에 가까울 수록 인덱스 효율이 좋겠죠
```

- 하지만, 선택도가 좋지 않더라도 정렬, grouping 작업을 위해 인덱스를 만드는 것이 좋은 경우도 있습니다.
 
- 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 레코드를 읽는 것보다 높은 비용입니다.
- 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배정도 비용이 더 많이 드는 작업인 것으로 예측합니다.
- 즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 full scan 하여 필요한 레코드만 가려내는(필터링) 방식으로 처리합니다.
- 
- 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

- MySQL 이 어떻게 인덱스를 이용해서 실제 레코드를 읽어 낼까?
- MySQL 이 인덱스를 어떤 방식으로 읽는지 알아봅니다.

- 인덱스 레인지 스캔
- 
- 인덱스의 범위가 결정됐을 때 사용하는 방식
1. 쿼리가 들어오면 루트노드 → 브랜치노드 → 리프 노드 순으로 읽을 시작 위치를 찾는다. (인덱스 탐색)
2. 찾으면 그때부터는 읽을 시작 위치부터 필요한 만큼을 순서대로 읽는다.(인덱스 스캔)
3. 2번에서 읽은 인덱스 키와 레코즈 수로를 이용해 레코드가 저장된 페이지를 읽어 레코드를 가져온다 → 이는 RandomI/O 방식으로 레코드를 읽습니다 why ? 세컨더리 인덱스도 정렬되어있고, 레코드는 InnoDB 엔진 특성 상 PK로 정렬되어 있기 때문에.

- 만약, 커버링 인덱스로 처리되는 쿼리는 3번 과정을 생략하지 않습니다.
- 커버링 인덱스란, 인덱스로도 쿼리를 처리할 수 있어서 디스크의 레코드를 읽지 않는 것입니다.
- 이는 디스크로의 접근을 생략하기 때문에 RandomI/O 가 발생하기 않고, 성능은 그만큼 빨라집니다.
- 하지만, 쿼리를 커버링 인덱스로 처리하기 위해 해당 쿼리가 필요하는 데이터들을 묶어 무작정 인덱스를 생성하면 안됩니다.
- 커버링 인덱스를 만든다는 것은 그만큼 인덱스의 키의 크기가 커진다는 의미고, 키의 크기가 커지면, 한 페이지에 읽을 수 있는 노드가  줄어들어 디스크I/O 가 증가할 수 있습니다.
- 하지만, 잘 사용하면 좋겠죠? 혹은 쿼리를 개선하거나 ..ㅎ
-
- 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 모두 읽는 방식입니다.

- 쿼리의 WHERE 절에 사용된 column 이 인덱스의 첫 번째 column 아닌 경우, 사용됩니다.
- ex) A, B, C 의 순서로 만들어진 인덱스가 있지만, 쿼리의 WHERE 절이 B or C 로 시작하는 경우입니다.

- 쿼리가 커버링인덱스로 처리될 수 있다면 주로 이 방식이 사용됩니다. 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않습니다.
- 
- 인덱스 레인지 스캔보단 느리지만, 테이블 풀 스캔보단 빠릅니다.

- 5.7 버전의 루스(Loose) 인덱스 스캔

- 듬성듬성하게 인덱스를 읽는 것을 의미한다.
- group by 또는 MAX() , MIN() 함수에 대해 최적화를 하는 경우에 사용됨
- 이를 사용하려면 10장 실행 계획에서 자세히 언급

- 인덱스 스킵 스캔

- 인덱스의 핵심은 값이 정렬되어있다는 것. → 칼럼의 순서가 매우 중요하다.
- 8.0부터는 옵티마이저가 gender column 을 건너뛰어서 birth_date 만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었습니다.
- 루스 인덱스 스캔은 group by 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용이 가능했지만 인덱스 스킵 스캔 (8.0 에 도입된)은 WHERE 조건절의 검색을 위해 사용가능하도록 용도가 훨씬 넓어짐. 인덱스를 여러개 만들 거를 1개만 만들어도 됩니다.
- 어떻게? 옵티마이저는 gender 컬럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 컬람의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리합니다. 
- → 이러한 좋은 기능을 사용하려면 인덱스를 설계 할때, 선택도가 높은 column 을 인덱스에 포함 시켜야 되지 않을까? 생각하지만, 인덱스 스킵 스캔을 사용하려면 선택도가 낮은 column 을 인덱스에 포함해야 합니다.
- 
- WHERE 조건절에 조건이 없는 선행 column 의 유니크 개수가 적어야하고, 쿼리가 커버링 인덱스여야 합니다.
- 유니크 개수가 많다면 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많아져서 오히려 성능이 느려질 수 있습니다.
- 그래서, 쿼리를 커버링 인덱스로 처리하여 diskI/O 를 줄이고 만약, 커버링 인덱스에 포함될 column 의 선택도가 낮으면 인덱스 스킵 스캔을 활용하기 위해 인덱스를 만들 수 있을 것 같습니다.
- 
- 8.3.5 다중 칼럼(Multi-column) 인덱스

- 2개 이상의 column 으로 인덱스가 구성됨을 의미
- 2번째 칼럼은 ㅓㅅ 번째 칼럼에 의존해서 정렬되어있는 것이 중요합니다.

- 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
- 
- 정렬된 인덱스를 어느 방향으로 읽을지는 실행 계획에 따라 다르다.
- 인덱스를 생성 시, 정렬을 선택할 수 있다.
- 5.7 버전에서는 ASC 와 DESC 혼합해서 인덱스 생성 x
- 8.0 부터는 가능 CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
- 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다. 예를들어, 레코드를 오름차순으로 저장했지만, 쿼리를 다음과 같이 하면
- SELECT * FROM employess ORDER BY first_name DESC LIMIT 5; → 옵티마이저는 역순으로 읽어서 내림차순으로 정렬된 상태로 결과를 얻는다.

- 8.3.6.1.2 내림차순 인덱스 ?
- 
- 복합인덱스에서 column 이 내림차순, 오름차순 혼합된 경우에는 MySQL 8.0 내림차순 인덱스로만 해결될 수 있다.
- 역순 정렬 쿼리가 정순 정렬 쿼리보다 더 시간이 오래 걸린다.
- 실제 InnoDB 인덱스 연순 스캔(인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지 부터 왼쪽으로 스캔)이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 이유 2가지
1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

- InnoDB 에서 레코드는 PK에 의해 정렬되어있기는 하지만, 물리적 구조(레코드의 실제 메모리 구조는 순서대로 배치되어있지는 않습니다.
- 일반적으로 인덱스를 ORDER BY —- DESC 쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스 보다는 내림차순 인덱스가 더 효율적이다.

- 8.3.7.1 비교 조건의 종류와 효율성

- 다중 column 인덱스에서 범위 조건(<, >, =)에 따라 인덱스 colum 의 활용 형태 및 효율이달라진다.
- B-Tree 는 왼쪽 기준 정렬 기반읭 ㅣㄴ덱스라는 것이 중요하다.
- 그래서, 인덱스 column 의 값이 Like %san 이면 해당 인덱스 column를 사용할 수 없고,
- 다중 column 에서 (id, stay_id) 인 인덱스 가 있을 때, stay_id 만 WHERE에 있으면 해당 인덱스를 사용할 수 없다. Group By, Order BY 도 마찬가지다.
- B-Tree 인덱스 특성상 사용할 수 없는 쿼리 몇개를 알아보자.
1. NOT-EQUAL 로 비교된 경우
- WHERE column <> ‘N’
- WHERE column NOT IN (10, 11, 12)
- WHERE column is NOT NULL

1. LIKE %??
2. 다른 연산자로 인덱스 column 이 변형된 후 비교된 경우
- WHERE SUBSTRING(column, 1, 1) = ‘X’ 
- … 등등 있따. 결국 중요한 것은  → 해당 조건이 결국 인덱스 정렬의 특성을 사용할 수 없이 모든 레코드를 봐야한다.
- 
- 여기서 일반적인 DBMS는 인덱스에 NULL을 저장할 수 없지만, MySQL 은 인덱스에 NULL 을 저장할 수 있어서 `WHERE column IS NULL` 같은 쿼리는 인덱스를 사용할 수 있다.
- 이렇게 B-Tree 인덱스의 특징은 MySQL 뿐 아니라 대부분 RDBMS에도 동일하게 적용된다.