# ch05 인덱스
MySQL에서 사용 가능한 인덱스의 종류 및 특성을 살펴봅니다.

## 8.1 디스크 읽기 방식
### 8.1.1 하드 디스크 드라이브와 솔리드 스테이트 드라이브 (HDD vs SSD)
컴퓨터에서 가장 느린 부분은 데이터 저장 매체. 따라서 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건인 경우가 많음
#### SSD?
> 기존 하드 디스크 드라이브에서 원판을 제거하고 플래시 메모리를 장착하고 있는 전자식 저장 매체
- HDD와 다르게 디스크 원판을 회전시킬 필요가 없어 데이터를 빨리 읽고 쓸 수 있다.
- 하지면 당연하게도 CPU나 메모리보다는 속도가 느리다.
- SSD의 장점은 **HDD보다 `랜덤 I/O` 작업이 빠르다는 것**이다.

### 8.1.2 랜덤 I/O와 순차 I/O
예를 들어 3개의 페이지를 디스크에 기록하기 위한 경우에
- 순차적으로 I/O 작업을 하는 경우는 1번만 시스템 콜을 요청한다. &rarr; 디스크의 헤드를 1회만 움직인다.
- 랜덤으로 I/O 작업을 하는 경우는 3번 시스템 콜을 요청한다 &rarr; 디스크의 헤드가 3번 움직인다.

여러 번 요청을 하게 되는 랜덤 I/O 작업이 작업 부하가 훨씬 더 크다. 디스크 원판이 없는 SSD도 여전히 순차 I/O보다 랜덤 I/O 작업이 작업 부하가 크다.
따라서 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하여, 랜덤 I/O 자체를 줄이는 것이 중요!

## 8.2 인덱스란
> 인덱스는 책의 색인에 비유할 수 있다. 인덱스 또한 색인처럼 주어진 순서로 미리 값을 정렬하여 보관한다.
- 색인 : 인덱스
- 책의 내용 : 데이터 파일
- 색인의 페이지 번호 : 데이터 파일에 저장된 레코드의 주소

자료구조로도 인덱스와 데이터 파일을 비유할 수 있다. 인덱스는 정렬을 유지하고, 데이터 파일은 그렇지 않다.
- 인덱스-SortedList / 데이터 파일-ArrayList
- SortedList는 쓰기는 느리지만, 읽기는 빠르다. &rarr; 인덱스가 많은 테이블 역시 INSERT, UPDATE, DELETE 문장의 처리가 느리지만, SELECT 문은 매우 빠르다.

결론적으로는 인덱스는 데이터의 저장 성능을 희생하고 대신 데이터의 읽기 성능을 높히는 기능이다.

### 역할별로 구분 : 프라이머리 키 & 세컨더리 키
#### 프라이머리 키
- 레코드를 대표하는 칼럼으로 만들어진 인덱스 aka 식별자
- NULL 값과 중복을 허용하지 않는다.
#### 세컨더리 키(세컨더리 인덱스)
- 프라이머리 키 인덱스를 제외한 나머지 모든 인덱스는 세컨더리 인덱스이다.

### 데이터 저장 방식별로 구분 : B-Tree & Hash
#### B-Tree
- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
#### Hash
- 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘 

### 중복 허용 여부로 구분 : 유니크 인덱스 & Non-유니크 인덱스
- 유니크 인덱스인 경우 = 동등 조건으로 검색하면 항상 하나의 결과만이 나오는 것을 옵티마이저에게 알려주는 효과가 있다.

## 8.3 B-Tree 인덱스 (Balanced-Tree Index)
### 8.3.1 구조 및 특성
- 트리 구조 최상위에 하나의 루트 노드가 존제하고, 밑에 자식 노드가 붙어 있는 형태이다
- 가장 하위에 있는 노드를 리프 노드, 루트 노드와 리프 노드가 아닌 중간 노드들을 브랜치 노드라고 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- 데이터 파일의 레코드는 삭제나 변경 때문에 항상 INSERT한 순서대로 저장되는 것은 아니다.
#### MyISAM vs InnoDB
- MyISAM 테이블의 인덱스 리프 노드에는 인덱스 키와 레코드의 주소가 매칭되어 있어서 이 레코드의 주소로 바로 데이터 파일에서 레코드를 찾을 수 있다.
- 하지만 InnoDB의 세컨더리 인덱스는 값으로 레코드 주소가 아닌 프라이머리 키를 가지고 있기 때문에, 무조건 프라이머리 키 인덱스를 한 번 더 검색해서 데이터 파일을 찾아가야 한다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
InnoDB 스토리지에서는 인덱스 키 (중복 체크가 필요하지 않은 경우) 추가, 삭제, 변경 작업을 지연시킬 수 있는 기능을 제공한다.
#### 8.3.2.1 인덱스 키 추가
B-Tree에 값을 저장할 때 리프 노드가 꽉 차서 저장이 불가능하다면, 리프 노드가 분리되어 상위 브랜치의 노드들까지 영향을 끼치게 된다.  
따라서 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다고 알려졌다.
- 테이블에 레코드를 추가하는 작업 비용이 1이라면, 인덱스에 키를 추가하는 작업 비용은 1.5 정도
- 이런 비용의 차이가 나는 이유는 디스크로부터 인덱스 페이지를 읽고 쓰기를 하는데 시간이 걸리기 때문이다.

#### 8.3.2.2 인덱스 키 삭제
B-Tree에서 키 값을 삭제하는 경우는, 삭제하고자 하는 키 값이 저장된 리프 노드를 찾아 삭제 마크를 하게 된다.
- 마킹된 인덱스 키 공간은 재사용하거나 혹은 방치되기도 한다.

#### 8.3.2.3 인덱스 키 변경
인덱스의 키를 변경하게 되면 리프 노드의 위치 또한 변경되어야 하므로, 단순하게 인덱스 키만 변경하는 것은 불가능하다. 따라서 먼저 삭제를 한 후, 새로 추가되는 식으로
변경이 처리된다.

#### 8.3.2.4 인덱스 키 검색
인덱스는 트리 탐색 과정을 통해 검색 작업을 진행한다. 또 단순히 SELECT 작업 뿐 아니라 UPDATE와 DELETE 작업에도 키 검색이 필요하다.
- B-Tree 인덱스 검색은 100% 일치, 값의 앞부분이 일치하는 경우에 사용할 수 있고, 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다.
- InnoDB 스토리지 엔진에서는 적절한 인덱스가 설정되어 있지 않은 경우 불필요하게 많은 인덱스를 잠글 수 있음에 주의하자

### 8.3.3 B-Tree 인덱스 사용에 영향을 끼치는 요소
인덱스를 구성하는 칼럼의 크기, 러코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 영향을 받는다.
#### 8.3.3.1 인덱스 키 값의 크기
- 페이지? &rarr; 디스크에 데이터를 저장하고, 버퍼 풀에서 데이터를 버퍼링하는 가장 기본 단위. 블럭이라고도 부른다.
- 일반적으로 페이지의 크기는 정해져 있는데, 그 내부에 저장되는 인덱스 키 크기가 늘어난다면? 당연히 한 페이지에 저장할 수 있는 인덱스 키가 적어진다.  
   **&rarr; 즉 인덱스 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 속도가 느려진다**

#### 8.3.3.2 B-Tree의 깊이
인덱스 키 값의 크기는 트리의 깊이에도 영향을 준다. 레코드 건수가 같다고 하더라도 하나하나의 크기가 크다면 더 많은 페이지가 필요하고, B-Tree의 깊이가 깊어진다.  
따라서 디스크 읽기 횟수가 많아질 수 밖에 없다.

#### 8.3.3.3 선택도(가수성)
> 모든 인덱스 키 값 가운데 유니크한 값의 수
- 가수성이 높아지면 검색 대상이 줄어들기 때문에 그만큼 빠른 처리가 일어난다.
- 전체 레코드 수 1만건에서 칼럼의 가수성 10개 vs 1000개인 경우 &rarr 전자는 평균 1000건, 후자는 평균 10건이 조회되리라는 것을 예측 가능하다.
- 두 경우 다 1건만의 레코드가 결과로 나온다고 생각해보면 전자는 999건의 쓸모없는 레코드를 더 읽은 셈이 된다.
- 이처럼 인덱스에서 유니크한 값의 개수는 쿼리의 효율성에 큰 영향을 미친다.

#### 8.3.3.4 읽어야 하는 레코드의 건수
인덱스를 거쳐서 테이블의 레코드를 읽는 것은 바로 테이블의 레코드를 읽는 것 보다 더 높은 비용이 드는 작업이다. 따라서 인덱스로 읽는 것과 바로 전체 테이블을 읽는
것 중 어떤 것이 더 효율적일지 판단이 필요하다.
- 일반적으로 인덱스를 통해 1건의 레코드를 읽는 것이 4~5배 정도 비용이 더 많이 드는 것으로 예측된다.
- 인덱스를 통해 읽어야 할 건수가 전체의 20% ~ 25% 를 넘어가면 전체 테이블 스캔 후 필터랑 방식이 효율적이다.
- 따라서 옵티마이저는 쿼리를 실행할 때 인덱스를 태울지 전체 테이블을 읽을지를 판단해서 실행 계획을 세운다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
MySQL이 인덱스를 이용하는 방법을 알아본다.
#### 8.3.4.1 인덱스 레인지 스캔
> 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식으로, 인덱스의 루트 노드부터 시작해 리프 노드까지 가서 시작 위치를 찾은 다음 리프 노드의 레코드를 순서대로 읽는다.  
> 진행하다가 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 내용을 반환하고 끝낸다.
- 이 방식에서는 범위 스캔이기 때문에 칼럼의 정순/역순으로 정렬된 상태의 인덱스를 가져오게 된다.
- 스캔을 하면서 검색 조건에 일치하는 건들은 실제 데이터 파일 주소를 타고 들어가서 값을 읽어와야 하는데 이 과정에서 랜덤 I/O가 일어난다.
- 만일 커버링 인덱스로 처리되는 쿼리가 있다면 데이터 파일을 읽지 않아도 되고, 성능은 당연히 읽는 것 보다 더 빠르다.
#### 8.3.4.2 인덱스 풀 스캔
> 인덱스의 처음부터 끝까지 모두 읽는 방식. 쿼리에 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔이 실행된다.
- 예를 들면 (A,B,C)로 만들어진 인덱스를 사용하면서 B나 C로 검색하는 경우
- 인덱스 레인지 스캔보다는 느리지만, 테이블 풀 스캔보다는 인덱스 풀 스캔이 더 효율적이다.
#### 8.3.4.3 루스 인덱스 스캔
> 느슨하게, 듬성듬성하게 인덱스를 읽는 방식. 스캔하면서 중간에 필요하지 않은 레코드들은 그냥 스킵해서 넘어가는 식으로 작동한다.
#### 8.3.4.4 인덱스 스킵 스캔
> 인덱스가 여러 개의 칼럼으로 이루어져 있을 경우 두 번째 칼럼으로 검색하게 되면 인덱스를 사용하지 못하는 쿼리가 되었었는데, MySQL 8.0부터 두 번째 칼럼만으로도
> 인덱스 검색이 가능하게 해준다.
```sql
// 인덱스 추가
ALTER TABLE employees ADD INDEX my_index (gender, birth_date);

// 실행계획 확인
EXPLAIN SELECT gender, bitch_date FROM employees WHERE birth_date >= `1965-02-01`;
+----+------------+-------+------------+----------------------------------------+
| id | table      | type  | key        | extra                                  |
+----+------------+-------+------------+----------------------------------------+
| 1  | employees  | range | my_index   | Using where; Using index for skip scan |
+----+------------+-------+------------+----------------------------------------+
```
- 두 번째 칼럼으로 검색하는 경우더라도, 인덱스 스킵 스캔으로 인해 인덱스가 사용되고 있고 꼭 필요한 부분만 읽고 있다는 것을 확인할 수 있다.
- 옵티마이저가 우선 첫 번째 gender 칼럼에서 유니크한 값을 조회한 다음, 주어진 쿼리에 gender 칼럼의 조건을 추가해서 다시 실행하는 식이다.
```sql
// 아래와 같은 쿼리 실행
SELECT  gender, birth_date FROM employees WHERE gender=`F` and birth_date >= `1965-02-01`;
SELECT  gender, birth_date FROM employees WHERE gender=`M` and birth_date >= `1965-02-01`;
```
- 인덱스 스킵 스캔의 단점도 존재한다.
  - 조건절에 없는 인덱스의 선행 칼럼 중 유니크한 값의 개수가 적어야 한다 &rarr; 개수가 많을 경우 스캔해야할 시작 지점을 검색하는데 비용이 많이 들어가 더 느려질 수 있다.
  - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 한다 (커버링 인덱스) &rarr 커버링 인덱스가 불가능할 경우, 나머지 칼럼들도 필요해지기 때문에 풀 테이블을 스캔해야 하기 때문
#### 💡 루스 인덱스 스캔 vs 인덱스 스킵 스캔?
- 루스 인덱스 스캔 : GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용 가능 &rarr; 각 그룹별로 필요한 부분만 읽고 나머지 스킵하는 식으로
- 인덱스 스킵 스캔 : 꼭 GROUP BY 작업 뿐 아니라 WHERE 조건절의 검색을 위해 사용 가능하도록 확대된 것

### 8.3.5 다중 칼럼 인덱스
> 두 개 이상의 칼럼으로 구성된 인덱스. 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존하여 정렬되어 있다.  
> 즉 두번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 경우에만 의미가 있다.
- 따라서 다중 칼럼 인덱스는 인덱스 칼럼의 순서가 아주 중요하다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
인덱스가 만들어질 때 인덱스의 키 값은 항상 오름차순 혹은 내림차순으로 정렬된 형태로 만들어진다. 어떠한 형태로 만들어지든지 읽는 방향에 따라 오름차순 & 내림차순으로 모두 읽을 수 있다.
#### 8.3.6.1 인덱스의 정렬
MySQL 8.0 버전에서부터는 칼럼 단위로 정렬 순서를 혼합해서 인덱스를 생성하는 것이 가능하다.
#### 8.3.6.1.1 인덱스 스캔 방향
- 인덱스 생성 시점에 정렬 방법이 결정되지만 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향을 옵티마이저가 결정하여 실행한다.
- 오름차순 정렬 인덱스의 경우
    &rarr; 정순으로 읽으면 오름차순 정렬
    &rarr; 역순으로 읽으면 내림차순 정렬
#### 8.3.6.1.2 내림차순 인덱스
InnoDB 스토리지 엔진에서 정순과 역순 스캔은 페이지 간의 양방향 연결 고리를 통해 전진하느냐 후진하느냐의 차이만 있지만, 실제로 속도에 차이가 나는 내부적 이유가 있다.
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
#### 💡 왜 정순 스캔에 더 최적화 되어 있다는 것일까?
[참고자료](https://tech.kakao.com/posts/351)  
우선 기본적으로 InnoDB에서는 정순 스캔에 맞추서 인덱스가 설계되어 있다.
- InnoDB는 다음 페이지로 이동할 때 현재 페이지의 잠금을 해제하고, 읽어야 하는 다음 페이지에 새롭게 잠금을 건다.
- 따라서 정순 스캔으로 이동할 경우 1페이지 읽고 잠금 해제 &rarr; 2페이지 잠금 후 읽고 잠금 해제 .. 반복하게 되며 다른 트랜잭션에서 1페이지에 접근하더라도 문제가 되지 않을 것이다.
- 그렇지만 역순으로 읽는 경우에는 거꾸로이기 때문에 잠금의 획득과 해제도 반대 순서. 이 때 다른 트랜잭션에서 반대 방향으로 스캔을 하려고 하는 경우 서로 데드락이 발생할 수 있다..
- 따라서 역순 스캔은 필요하다면 이전 페이지의 잠금도 관리하는 것을 염두에 두어야 하며 이 때문에 정순 스캔보다 좀 더 복잡한 구조를 가진다.

### B-Tree 인덱스의 가용성과 효율성
어떤 조건에서 인덱스를 사용할 수 있고, 사용할수 없는지와 인덱스를 일부만 사용하는지, 100% 사용하는지에 대해 알아본다.
#### 8.3.7.1 비교 조건의 종류와 효율성
> 다중 칼럼 인덱스에서 칼럼의 순서와 조건(동등 조건, 범위 조건)에 따라 인덱스 칼럼의 활용 형태와 효율이 달라진다.
```sql
인덱스 1 : (dept_no, emp_no);
인덱스 2 : (emp_no, dept_no);

SELECT * FROM dept_emp WHERE dept_no = 'd002' and emp_no >= 10114;
```
인덱스의 순서에 따라 처리 과정이 달라지게 된다.  

1번 인덱스의 경우
 - 처음으로 dept_no = 'd002' and emp_no >= 10114 조건을 만족하는 인덱스를 찾고, 그 이후 dept_no가 d002가 아닐 때 까지 인덱스를 쭉 읽기만 하면 된다.

2번 인덱스의 경우
 - 우선 emp_no를 먼저 비교해야 하기 때문에 emp_no >= 10114 and dept_no = 'd002' 조건을 찾은 후. 이후 모든 레코드에 대해 dept_no가 d002인지 체크해야 한다.
 - 왜냐하면 첫 번째 인덱스 칼럼 값의 범위는 맞더라도 두 번째 인덱스 칼럼 값의 범위가 달라질 수 있기 때문이다.

정리하자면 ..
- 스캔에서 작업의 범위를 결정하는 조건과 비교 작업의 범위를 줄이지 못하고 단순히 필터링 역할만 하는 조건으로 나뉜다.
- 작업 범위 결정 조건은 많을수록 쿼리의 처리 성능을 높이지만, 체크 조건은 많다고 해서 쿼리의 성능이 높아지지 않고 오히려 실행을 더 느리게 만들 수도 있다.

#### 8.3.7.2 인덱스의 가용성
> B-Tree 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있다. 이는 다중 칼럼 인덱스에서도 역시 적용되는 내용이다.
- 다중 칼럼 인덱스에서 왼쪽 부분의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없게 된다.
#### 8.3.7.3 가용성과 효율성 판단
B-Tree 인덱스의 특성 상 작업 범위 결정 조건으로 사용할 수 없는 경우들이 몇몇 있다.
- Not-Equal 비교
- Like로 문자열 뒷부분 일치 패턴 비교
- 인덱스 칼럼이 변형된 후의 비교
- 데이터 타입이 서로 다른 비교
- 문자열 데이터 타입의 콜레이션이 다른 경우 비교
#### 다중 칼럼으로 만들어진 인덱스의 사용 조건
- 첫 번째 칼럼에 대한 조건이 없거나, 조건이 있더라도 위의 불가능한 경우에 해당되는 경우에는 작업 범위 결정 조건으로 사용 불가
- 다음과 같은 경우 작업 범위 결정 조건으로 인덱스 사용 가능
  - 첫 번째 칼럼부터 중간에 존재하는 칼럼들의 동등 비교
  - 중간에 존재하는 칼럼들에 대해 동등, 크다 작다 형태, like 좌측 일치 비교

## 8.4 R-Tree 인덱스
> 인덱스를 구성하는 칼럼의 값이 2차원의 공간 개념 값인 인덱스, 주로 2차원의 데이터를 인덱싱하고 검색하는 것이 목적이다.

위치 기반의 서비스를 위해 MySQL의 공간 확장을 이용할 수 있으며, 공간 확장에는 다음과 같이 크게 세 가지 기능이 있다.
- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스 (R-Tree 알고리즘)
- 공간 데이터의 연산 함수 (거리 또는 포함 관계의 처리)

### 8.4.1 구조 및 특성
> 공간 정보의 저장 및 검색을 위해 도형 정보를 관리할 수 있는 데이터 타입을 지원한다.

#### MBR
해당 도형을 감싸는 최소 크기의 사각형을 의미

> MBR들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스
- 포함 관계로 중첩된 MBR들 중에서 최상위 MRB(가장 큰 사각형)은 R-Tree의 루트 노드에 저장되며, 차상위 MRB는 브랜치 노드, 각 도형의 MRB는 리프 노드에 저장된다.

### 8.4.2 R-Tree 인덱스의 용도
R-Tree는 공간 인덱스라고도 한다. 일반적으로 GPS 기준의 위도 경도 저장에 주로 사용되지만 좌표 시스템에 기반을 둔 정보는 모두 적용할 수 있다.
- 각 도형의 포함 관계를 이용해 인덱스를 만들기 때문에 포함 관계를 비교하는 함수를 사용해야만 인덱스를 사용할 수 있다.