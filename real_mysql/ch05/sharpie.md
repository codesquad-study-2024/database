# 트랜잭션과 잠금
- 트랜잭션 : 작업의 완전성, 데이터 정합성 보장을 위한 기능
  - 논리적인 작업 셋을 모두 완벽하게 처리 / 못하는 경우에는 원 상태로 복구해 partial update 발생 방지 => 0 아니면 100, 모 아니면 도
- 잠금 : 동시성을 제어하기 위한 기능
  - 여러 커넥션에서 동시에 동일 자원 요청시 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 하는 역할
- 격리 수준 : 하나 또는 여러 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

## 트랜잭션
### MySQL에서의 트랜잭션
- MySQL에는 MyISAM, MEMORY 스토리지 엔진, InnoDB 스토리지 엔진이 있음

```
mysql> CREATE TABLE tab ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) ) ENGINE={엔진종류};
mysql> INSERT INTO tab (fdpk) VALUES (3);

-- // AUTO-COMMIT 활성화
mysql> SET autocommit=ON;

mysql> INSERT INTO tab (fdpk) VALUES (1), (2), (3);
```

- 위와 같이 테스트용 테이블에 각각 레코드를 1개씩 저장한 후, AUTO-COMMIT 모드에서 중복 레코드를 포함 세 개 레코드를 추가 저장한다고 할때
  - MyISAM이나 MEMORY의 경우 1, 2를 INSERT하는 순간까지는 문제 없다가 3을 저장하려는 순간 중복 키 오류가 발생
  - InnoDB의 경우 쿼리 중 일부라도 오류가 발생하면 트랜잭션의 원칙대로 실행 전 상태로 그대로 복구

```SQL
-- // 롤백 x MyISAM, MEMORY => IF, ELSE를 사용한 여러 가지 분기문

-- // 트랜잭션을 지원하는 InnoDB 사용
try {
  START TRANSACTION;
  INSERT INTO tab_a ...;
  INSERT INTO tab_b ...;
  COMMIT;
} catch(exception) {
  ROLLBACK;
}
```
- 부분 업데이트 현상은 데이터 정합성 보장을 어렵게 만든다. 레코드 삭제하는 재처리 작업을 다시 수행하게 하는 것보다, InnoDB의 트랜잭션 지원을 사용하는 것이 애플리케이션 개발에서 고민해야 할 문제를 줄여준다.

### 주의사항
- 트랜잭션 범위 최소화 필요
```
1) 처리 시작
  => 데이터베이스 커넥션 생성
  => 트랜잭션 시작
2) 사용자 로그인 여부 확인
3) 사용자 글쓰기 내용 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
  <= 트랜잭션 종료 (COMMIT)
  <= 데이터베이스 커넥션 반납
10) 처리 완료
```
- 트랜잭션 별도로 분리해야 하는 작업들 존재 -> 9
- 하나의 트랜잭션으로 묶어야 하는 작업들 존재 -> 5, 6
- 단순 확인 및 조회는 트랜잭션에 포함시키지 않아도 OK -> 7
- 트랜잭션에 포함시키지 않아도 되는 작업들 존재
  - 데이터베이스 커넥션은 수가 제한적 -> 2, 3, 4
  - 네트워크로 원격 서버와 통신하는 등과 같은 작업은 어떻게든 트랜잭션 내에서 제거하는 것이 좋음(메일 서버와 통신할 수 없어진다면 웹 서버 말고 DBMS 서버까지 위험해질 수도) -> 8

```
1) 처리 시작
2) 사용자 로그인 여부 확인
3) 사용자 글쓰기 내용 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
  => 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
  => 트랜잭션 시작
5) 사용자 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
  <= 트랜잭션 종료 (COMMIT)
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
  => 트랜잭션 시작
9) 알림 메일 발송 이력을 DBMS에 저장
  <= 트랜잭션 종료 (COMMIT)
  <= 데이터베이스 커넥션 종료(또는 커넥션 풀에 반납)
10) 처리 완료
```
- 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화되어 있는 프로그램의 범위를 최소화해야 한다.
- 네트워크 작업이 있는 경우 반드시 트랜잭션에서 배제해야 한다.
- 이렇게 대처해 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 것을 방지

## MySQL 엔진의 잠금
- 스토리지 엔진 레벨, MySQL 엔진 레벨로 나눌 수 있음
  - 스토리지 엔진 : 실제 데이터를 디스크에 저장하고 읽어오는 방식 결정. InnoDB, MyISAM, MEMORY 등 선택 가능
  - MySQL 엔진 : 쿼리 엔진. SQL 쿼리의 파싱, 최적화, 실행 담당. 클라이언트 연결 관리, 보안 및 권한 체크 수행. 전반적인 데이터베이스 기능 제어. => 스토리지 엔진을 제외한 나머지 부분으로 이해하면 됨
- 스토리지 엔진 레벨 잠금은 스토리지 엔진 간 상호 영향 미치지 x

### 글로벌 락
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득 가능
- MySQL 제공 잠금 중 가장 큰 범위, MySQL 서버 전체에 영향.
- 모든 데이터베이스의 모든 테이블에 대한 읽기 잠금. 쓰기 작업 차단
- 다른 세션에서 SELECT 이외 대부분의 DDL, DML 문장 실행 시 글로벌 락 해제 시까지 대기 상태로 남음
- mysqldump로 일관된 백업을 받아야 할 때는 글로벌 락 사용해야 함

> - 글로벌 락 명령 실행 전 레코드에 쓰기 잠금을 거는 SQL 실행 시 이 명령은 읽기 잠금을 걸기 위해 먼저 실행된 SQL과 그 트랜잭션이 완료될 때까지 대기
> - 읽기 잠금을 걸기 전에 먼저 테이블을 플러시해야 하기 때문에 테이블에 실행 중인 모든 종류 쿼리가 완료되어야 함
> - 장시간 실행되는 쿼리와 읽기 잠금이 최악의 케이스로 실행 시 오래 대기할 수 있으므로 웹 서비스용이라면 가급적 사용 지양
> - mysqldump와 같은 백업 프로그램은 글로벌 락을 사용하고 있을 수 있으므로 옵션에 따라 MySQL 서버에 어떤 잠금 거는지 확인하는 것이 좋음

- 복제 환경에서 고려 사항
  - 복제 서버에서 백업을 실행하는 도중 소스 서버에서 데이터 변경 시 복제 서버의 데이터가 최신 상태가 될 때까지 서비스를 멈춰야 할 수도
  - XtraBackup이나 Enterprise Backup 도구 사용시 스키마 변경이 실행되면 백업이 실패할 수 있음 (6-7시간 백업 실행하고 있는데, 갑자기 DDL 명령 하나로 백업 실패 시 다시 그만큼 시간 들여 백업 실행해야)
- 대안
  - MySQL 8.0부터 InnoDB가 기본 스토리지 엔진으로 채택. 조금 더 가벼운 글로벌 락의 필요성, 백업 락 도입
  - `LOCK INSTANCE FOR BACKUP` 명령
  - `UNLOCK TABLES`명령으로 글로벌 락 해제 가능
- 강력한 기능이나 서비스에 미치는 영향 크므로 반드시 필요한 경우에만 사용해야 하며 가능한 한 빨리 해제해야 함

#### 주의⚠️
- 읽기 잠금 -> 읽기를 금지한다는 말이 아니라, 읽기를 제외한 나머지 쓰기 작업을 차단한다는 뜻. 세션이 달라도 읽기 작업은 허용됨. 쓰기는 모두 차단
- 쓰기 잠금 -> 특정 리소스에 대해 쓰기 작업 수행하는 세션만 접근할 수 있게 함. 다른 세션의 읽기, 쓰기는 모두 차단.

### 테이블 락
- 개별 테이블 단위로 설정되는 잠금
- 명시적으로 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 특정 테이블의 락을 획득할 수 있음
- MyISAM뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다
- 명시적으로 획득한 잠금은 `UNLOCK TABLES` 명령으로 해제할 수 있음
- 특별 상황이 아니면 애플리케이션에서 사용할 필요 거의 없음. 글로벌 락과 동일하게 온라인 작업에 상당한 영향 끼치기 때문
- 묵시적인 테이블 락은 테이블에 데이터 변경 쿼리를 실행하면 발생. 자동 획득, 자동 해제
- InnoDB의 경우 스토리지 엔진 차원에서 레코드 기반 잠금 제공하므로 단순 데이터 변경 쿼리로 묵시적 테이블 락이 설정되지는 x
  - 대부분 DML에서는 무시, DDL에서만 영향

### 네임드 락
- GET_LOCK() 함수로 임의의 문자열에 대한 잠금 설정 가능
- 대상이 테이블이나 레코드 또는 AUTO_INCREMENT같은 데이터베이스 객체가 아니라는 것이 특징
- 단순히 사용자가 지정한 문자열에 대해 획득하고 반납(해제)하는 잠금
- 주로 복잡한 요구사항으로 인해 DB 트랜잭션으로 처리하기 어려운 경우 사용
- 사용 예: 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건이라면 네임드 락을 이용하면 쉽게 해결할 수 있음
- GET_LOCK(), IS_FREE_LOCK(), RELEASE LOCK() 함수로 락 관리 -> 반환값이 0이나 NULL, 1이므로 IF문과 함께 사용.

### 메타데이터 락
- 명시적으로 획득하거나 해제 불가 -> 테이블명 변경시 자동으로 획득하는 잠금
- RENAME TABLE 명령 실행 시, 원본 이름과 변경될 이름 두 개 모두에 대해 동시에 잠금 설정.
- 동시에 여러 개 RENAME 작업 한번에 실행시 데드락 발생 가능
- `RENAME TABLE rank TO rank_backup, rank_new TO rank;` 이 명령을 한번에 실행하지 않고 두개로 나누어 실행하면, 아주 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생겨 "Table not found 'rank'"오류 발생

#### 메타데이터 잠금과 InnoDB 트랜잭션을 동시에 사용해야 하는 경우
- INSERT만 있는 로그 테이블, 어느날 이 테이블 구조를 변경해야 할 때
- 변경된 구조를 가진 새 구조 임시 테이블 생성 -> 기존 테이블 데이터 새 테이블로 복사 -> 테이블 교체 -> 이전 테이블 삭제
- 남은 데이터 복사하는 시간동안 테이블 잠금으로 INSERT가 불가하므로, 가능하면 미리 아주 최근 데이터까지 복사해둬야 잠금 시간을 최소화해 서비스에 미치는 영향을 줄일 수 있다
