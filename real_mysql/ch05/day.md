# ch05 트랜잭션과 잠금
MySQL의 동시성에 영향을 미치는 잠금 & 트랜잭션 & 트랜잭션의 격리 수준을 살펴봅니다.

## 5.1 트랜잭션
### 트랜잭션이란
> 논리적인 작업 셋을 모두 완벽하게 처리하거나, 문제가 발생하는 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생되지 않도록 만들어주는 기능

#### 잠금 vs 트랜잭션
- `잠금`은 `동시성`을 처리하기 위한 기능이고, `트랜잭션`은 `데이터의 정합성`을 보장하기 위한 기능이다.
  - 예를 들면 `하나의 회원 정보 레코드를 여러 커넥션에서 동시에 처리`하고자 하는 경우  
    &rarr; 잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게 되어 해당 데이터는 예측할 수 없는 상태가 되는 문제 발생  

### 5.1.1 MySQL에서의 트랜잭션
트랜잭션은 꼭 여러개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미 있는 개념이 아니라, 하나의 논리적인 작업 셋에 쿼리가 몇개가 있든
`COMMIT` 실행 시 작업 셋 자체가 100% 적용되거나 혹은 `ROLLBACK`시 아무것도 적용되지 않아야 함을 보장하는 것이다.

#### 스토리지 엔진에 따른 차이 : InnoDB와 MyISAM
- MyISAM나 MEMORY 스토리지 엔진은 트랜젝션이 존재하지 않기 때문에 만일 여러 건의 데이터를 INSERT 하다가 오류로 실패하는 경우
성공한 부분까지는 DB에 실제로 반영된다.
- 이는 부분 업데이트 현상이라고 하는데, 이렇게 실패한 쿼리로 인해 남은 레코드들을 삭제 처리하는 일들이 필요할 수 있다. 하지만 이를
비즈니스 코드 상에서 처리하려면 너무 복잡한 코드가 될 것이다..


- 반면 트랜잭션 개념이 존재하는 InnoDB는 트랜잭션 덕분에 실패하면 같은 트랜잭션 내부라면 성공한 부분들도 함께 반영이 취소된다.

### 5.1.2 주의사항
프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋다! 트랜잭션의 범위를 설정하는 데 있어 주의해야 할 점들이 있다.
- 실제 데이터를 처리하는 부분부터 트린잭션을 시작하자
- 네트워크를 통해 외부와 통신하는 작업은 트랜잭션 내에서 제거하자
- 성격이 다른 작업들은 다른 트랜잭션으로 묶는 것이 좋다

이런 점들을 고려하여 DBMS 서버가 높은 부하 상태나 위험한 상태에 빠지지 않도록 해야 한다.

## 5.2 MySQL 엔진의 잠금
잠금은 `스토리지 엔진 레벨`과 `MySQL 엔진 레벨`로 나뉜다. `MySQL 엔진 레벨`에서의 잠금은 모든 스토리지 전체에 영향을 끼친다. 
반면 `스토리지 엔진 레벨`에서의 잠금은 스토리지 엔진 간 상호 영향을 끼치지 않는다.

여기서는 `MySQL 엔진 레벨`에서의 잠금 종류를 알아본다.
### 5.2.1 글로벌 락
> 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득 가능하며, MySQL에서 가장 범위가 넓은 잠금이다.

- 하나의 세션에서 글로벌 락을 획득한 경우 다른 세션에서 SELECT 문을 제외한 DDL, DML 명령들은 글로벌 락이 해제될 때 까지 대기상태가 된다.
- 글로벌 락은 테이블이나 데이터베이스에 상관 없이 MySQL 서버 전체에 영향을 미친다.
- 주로 MyISAM이나 MEMORY 테이블에서 mysqldump로 백업을 받을 때 사용한다.

#### 글로벌 락을 사용 시 주의
- 만일 `FLUSH TABLES WITH READ LOCK` 명령 이전에 쓰기 잠금 명령이 걸려 있는 상태라면, 먼저 실행된 이 명령이 완료될 때까지 글로벌 락 명령은 대기한다.
- 따라서 장시간 실행되는 쿼리문과 글로벌 락 명령이 최악의 케이스로 실행되는 경우 온 서버 모든 테이블의 속도에 안좋은 영향을 끼칠 수 있음을 생각해야 한다.

### 💡 쓰기 잠금 vs 읽기 잠금
#### 쓰기 잠금 (배타적 잠금)
데이터의 추가나 변경을 위해 쓰기 잠금을 획득하는 경우에는 해당 트랜잭션에서 작업이 완료되고 잠금이 해제될 때까지 해당 데이터를 다른 트랜잭션에서 읽거나 쓸 수 없다.
- 쓰기 잠금이 걸려 있는 동안에는 읽기 잠금을 동시에 걸 수 없다.
- 쓰기 잠금이 걸려 있는 동안에는 쓰기 잠금을 동시에 걸 수 없다.
#### 읽기 잠금 (공유 잠금)
데이터를 읽기 위해 읽기 잠금을 획득하는 경우에는 다른 트랜잭션에서 데이터를 수정할 수 없으며, 오직 읽기만 가능하다.
- 하나의 데이터에 읽기 잠금이 여러 개 설정될 수 있다.
- 쓰기 잠금과는 충돌이 발생하기 때문에, 하나의 데이터에 읽기 잠금이 걸려있는 경우 동시에 쓰기 잠금을 걸 수 없다.

### 5.2.2 테이블 락
> 테이블 락은 `LOCK TABLE table_name [READ | WRITE]` 명령으로 명시적으로 획득 가능하며, 개별 테이블 단위로 설정되는 잠금이다.
> 락을 반납할 때는 `UNLOCK TABLES` 명령으로 해제 가능하다.
- MyISAM이나 MEMORY 엔진에서는 테이블 데이터를 변경하는 쿼리를 실행하면 묵시적으로 테이블 락이 발생한다.
- InnoDB는 DDL 쿼리에서만 테이블 락이 설정되고, DML 쿼리에서는 무시된다.

### 5.2.3 네임드 락
> 네임드 락은 `GET_LOCK()` 함수를 이용해서 임의의 문자열에 대해 잠금을 건다. 테이블이나 레코드, DB객체가 아닌 단순 String 문자열에 잠금을 거는 락이다.
> 이를 이용해 여러 클라이언트가 동시에 특정 작업을 사용할 수 없도록 제어할 수 있다.
- 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 활용할 수 있다.
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 경우에 활용할 수 있다.

### 5.2.4 메타데이터 락
> 메타데이터 락은 테이블이나 뷰와 같은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
> 명시적으로 획득할 수는 없고, `RENAME TABLE A TO B`와 같이 테이블의 이름을 변경할 때 자동으로 획득된다.

## 5.3 InnoDB 스토리지 엔진 잠금
MySQL이 제공하는 잠금과 별개로, InnoDB 스토리지 엔진 자체에서 레코드 기반의 잠금 방식이 탑재되어 있다. 따라서 상대적으로 뛰어난 동시성 처리를 제공 가능하다.

- `information_schema` 데이터베이스의 `INNODB_TRX` `INNODB_LOCKS` `INNODB_LOCK_WAITS` 테이블을 조인해서 현재 트랜잭션 잠금 현황을 확인할 수 있다.
- `Performance Schema`를 이용하여 스토리지 엔진의 세마포어에 대한 모니터링 방법도 추가됐다.

### 5.3.1 InnoDB 스토리지 엔진의 잠금
- 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 락 에스컬레이션은 없다.
- 레코드 락 뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

#### 5.3.1.1 레코드 락
> 레코드 자체만을 잠그는 락이다. 중요한 점은 InnoDB에서는 레코드 자체가 아니라 인덱스의 레코드에 잠금을 건다는 점이다.
- 프라이머리 키, 유니크 인덱스에 의한 변경 작업에서는 레코드 자체에 대해서만 락을 건다.

#### 5.3.1.2 갭 락
> 갭 락은 레코드와 바로 인접한 레코드 사이의 간격을 잠그는 것을 의미한다. 이렇게 함으로써 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어한다.
- 갭 락은 그 자체로 사용되기보다는 넥스트 키 락의 일부로 자주 사용된다.

#### 5.3.1.3 넥스트 키 락
> 레코드 락 + 갭 락 형태의 잠금을 넥스트 키 락이라고 하다.
- 갭 락과 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서와 동일한 결과를 만들어내도록 보장하기 위해 사용된다.
- 그런데 데드락이 생기는 경우가 자주 있으므로, 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 갭 락과 넥스트 키 락을 줄이는 것이 좋다고 한다.

#### 💡 바이너리 로그?
- DB에서 일어나는 변경 사항을 기록하는 파일로 복제나 데이터 백업 등에 사용된다.
- 바이너리 로그에는 세가지 포맷이 있다.
  - ROW : 변경된 행이 어떻게 변경되었는지 데이터를 변경한 내용 기록
  - STATEMENT : SQL 문장 자체를 바이너리 로그에 기록 &rarr; 쿼리문 자체를 저장하는 것이기 때문에 쿼리가 실행될 때 상황이 변경되었다면 동일한 결과가 아닐 수 있다.
  - MIXED : 둘을 섞어서 사용

#### 5.3.1.4 자동 증가 락
> `AUTO_INCREMENT` 를 이용해 자동으로 숫자를 채번하는 경우 중복되지 않고 증가하는 숫자를 얻기 위해 자동 증가 락을 사용한다.
- `INSERT`나 `REPLACE` 쿼리에서 `AUTO_INCREMENT`를 가져오는 잠깐의 순간만 해당 락이 걸렸다가 해제된다.
- MySQL 5.1부터는 `innodb_autoinc_lock_mode`시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있게 되었다.

### 5.3.2 인덱스와 잠금
InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스틑 잠그는 방식으로 처리된다. 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락이 걸리게 된다.

```sql
// 사원 테이블에서 Georgi 라는 성을 가진 사원은 전체 253명
SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi';
+----------+
|      253 |
+----------+

// 사원 테이블에서 Georgi 라는 성, Klassen이라는 이름을 가진 사원은 1명
SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi' AND last_name = 'Klassen';
+----------+
|        1 |
+----------+

// 해당 사원의 입사 일자를 오늘로 변경해본다.
UPDATE employees SET hire_date=NOW() WHERE first_name = 'Georgi' AND last_name = 'Klassen';
```
- UPDATE 문이 실행되면 1건의 레코드가 업데이트 될 것이다. 하지만 이 업데이트를 위해 락이 걸리는 레코드는 253개가 된다.
- 만약 인덱스가 하나도 없다면 테이블 풀 스캔이 들어가면서 모든 레코드가 잠기게 되는 불상사가 일어난다.
- 따라서 UPDATE을 위해 적절한 인덱스를 준비하는 것이 중요하다.

### 5.3.3 레코드 수준의 잠금 확인 및 해제
InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준 잠금보다 좀 더 복잡하다.  
왜냐하면 테이블 잠금은 테이블 자체가 잠금의 대상이므로 쉽게 문제의 원인을 발견하고 해결할 수 있지만, 레코드 수준의 잠금은 테이블 내부 레코드의 각각에 잠금이 걸리므로
문제를 발견하기가 좀 더 어렵다.

이를 위해 레코드의 잠금과 잠금을 대기하는 클라이언트의 정모를 확인하고 강제로 해제하는 명령들이 존재한다.

## 5.4 MySQL의 격리 수준
트랜잭션의 격리 수준이란 여러 트랜잭션들이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것이다.

### 5.4.1 READ UNCOMMITTED
> 각 트랜잭션에서의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부에 상관 없이 다른 트랜잭션에서 확인 가능한 격리 수준이다.
- A 사용자가 새로운 레코드를 `INSERT` 후 커밋을 하지 않아도, B 사용자가 이 `INSERT`한 내용을 볼 수 있다.

#### Dirty READ
- 다만 만일 A 사용자가 트랜잭션 수행 도중 문제가 발생하여 `INSERT` 한 값이 롤백된다고 하더라도, B는 여전히 해당 값이 있는 것으로 인식하는 문제가 있다.
- 이러한 현상을 더티 리드라고 하며 더티 리드가 허용되는 격리 수준이 `READ UNCOMMITTED`다.

### 5.4.2 READ COMMITTED
> 각 트랜잭션에서 `COMMIT`이 완료된 내용만 다른 트랜잭션에서 조회가 가능한 격리 수준이다.
- 따라서 더티 리드 현상은 이 격리 수준에서는 나타나지 않으며, 오라클 DBMS에서 기본적으로 사용되는 격리 수준이다.
- A 사용자가 특정 레코드의 값을 변경하는 트랜잭션을 진행 중이라면, 변경 전 내용은 언두 로그에 저장된다. 따라서 만일 B 사용자가 동일한 레코드를 읽는다고 하면 언두 로그의 값을
읽게 되기 때문에 변경 전의 데이터를 읽을 수 있게 되는 것이다.

#### NON-REPEATABLE READ
- 다만 `NON-REPEATABLE READ` 라는 부정합의 문제가 있다.
  - B 사용자가 트랜잭션을 시작하여 먼저 직원 번호 1번의 이름을 조회한다고 하자. 그런데 B 사용자의 조회 후, A 사용자가 1번 직원의 이름을 수정하고 커밋한다.  
  그 다음으로 B 사용자가 다시 1번 직원의 이름을 조회하게 되면 A 사용자가 이름을 수정했기 때문에, B 사용자가 첫 번째로 조회한 이름과 두 번째로 조회한 이름이 달라지게 된다.
  - 이는 사용자가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 똑같은 결과를 가져와야 한다는 `REPEATABLE READ` 정합성에 어긋난다.

### 5.4.3 REPEATABLE READ
> 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 안에서는 동일한 결과를 보여줄 수 있게 보장해주는 격리 수준이다.
- MySQL InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.
- 5.4.3예시에서 이어서 설명해보자면
  - B 사용자가 현재 진행 중인 트랜잭션 번호가 5번, A 사용자의 수정 트랜잭션 번호가 6번이라고 하면, B 사용자의 5번 트랜잭션 내부에서 실행되는 쿼리들은 트랜잭션 번호가 5번보다 작은
  트랜잭션 번호에서 변경된 값들만 보게 된다.
  - 따라서 A 사용자가 값을 변경했더라도 B 사용자는 기존 값을 읽어올 수 있게 된다.
- 해당 격리 수준에서는 `MVCC`의 보장을 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.
- 특정 트랜잭션 번호 구간 내에서 백업된 언두 데이터가 보존되어야 한다.

#### PHANTOM READ
만일 예시에서 B 사용자가 사원번호가 5보다 작은 모든 사원을 조회하고, A 사용자가 중간에 기존 레코드를 수정한 것이 아니라 새롭게 2번 사원을 한 줄 추가했다고 가정해 보자.  
그렇다면 B 사용자는 두 번째 조회를 할 때 첫 번째 조회에서는 없었던 이 새로운 2번 사원을 포함한 결과를 받게 된다. 즉 같은 트랜잭션 안에서 데이터가 없었다가 갑자기 나타난 셈으로,
이를 `PHANTOM READ`라고 한다

- 다만 `InnoDB`에서는 갭 락과 넥스트 키 락을 이용해서 `REPEATABLE READ` 수준에서도 `PHANTOM READ`가 발생하지 않는다.

### 5.4.4 SERIALIZABLE
> 읽기 작업도 공유잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 읽고 쓰는 작업중인 해당 레코드를 절대 접근할 수 없는 격리 수준이다.
- 가장 엄격한 격리 수준으로, `PHANTOM READ`가 나타나지 않는다.
- 예를 들어 A 사용자가 `SELECT`를 위해 조건 범위를 지정해서 검색을 하는 경우 해당 조건 범위에 있는 부분에 모두 잠금이 걸리기 때문에 데이터가 추가될 수 없는 것이다.